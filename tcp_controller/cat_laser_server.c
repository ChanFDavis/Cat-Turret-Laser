#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

/* Inclusions specific to TCP socket programming. */
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

/* This needs to be generated by the user. */
#include "client_server_const.h"

/* Provides a shorthand way of handling errors. */
void error(const char *msg) {
	perror(msg);
	exit(-1); /* TODO: Add other status return codes. */
}

/* TODO: Add docstring. */
int main(void) {
   int sock_fd 	= -1; /* Server socket file descriptor. */
	int newsock_fd = -1; /* Client connection socket file descriptor. */

   socklen_t client_len = 0u; /* Size of the struct that holds the client address information */
   ssize_t bytes_read = -1; /* The number of bytes read from the client, or -1 if read was unsuccessful. */
   size_t client_str_len = 0u; /* Size of the string read from clients. */

   char s_addr_str[INET_ADDRSTRLEN] = {0}; /* Holds the IP address to print */
   char client_str[BUFFER_SIZE] = {0}; /* Contains what a client has sent as an argument */

   struct sockaddr_in server_addr = {0}; /* Holds the server address information */
   struct sockaddr_in client_addr = {0}; /* Holds the clients' address information */

	printf("Starting cat laser turret TCP server.\n");

   /* Create a new socket and save entry in file descriptor table */
	sock_fd = socket(AF_INET, SOCK_STREAM, 0);

   if (sock_fd < 0) { error("ERROR: Failed to create the server socket."); }

   printf("Server socket successfully created.\n");

   /* Populate the server address structure with the correct information. */
   server_addr.sin_family = AF_INET; /* Internet domain sockets address family (IPv4). */
   server_addr.sin_port = htons(PORT); /* Convert port number (short) from host byte order to network byte order. */
   server_addr.sin_addr.s_addr = htonl(INADDR_ANY);  /* Local host address (long) converted from host byte order to network byte order. */

   /* Bind the socket to our sever's address. If unsuccessful, exit with error message. */
	if (bind(sock_fd, (struct sockaddr *) &server_addr, sizeof(server_addr)) < 0) {
	   error("ERROR: Error binding the server socket");
   }

   /* Listen on the socket for a client to connect. Only one client is allowed to connect. */
	if(listen(sock_fd, 1) < 0) {
      error("ERROR: Error listening on socket");
   }

   /* Alert user that the server has started listening for client connections on the given port. */
	printf("Listening on port %d...\n", PORT);

	/* Loop to keep accepting new clients. */
   while (1) {

		/* Accept a connect request from an incoming client. */
		client_len = sizeof(struct sockaddr_in);

      newsock_fd = accept(sock_fd, (struct sockaddr *) &client_addr, &client_len);

		if (newsock_fd < 0) {
         error("Error accepting connect to new client");
      }

      /* Read what the client sent. */
      bytes_read = read(newsock_fd, client_str, BUFFER_SIZE);

      /* Check if the read was successful. */
      if (bytes_read < 0) {
         error("ERROR: Unable to read bytes of data from the client.");
      } else {
         client_str_len = strlen(client_str);

         printf("Received the following from a client: %s\n", client_str);

         /* If client wishes to quit, close all socket connections and close. */
         if (!strcmp("quit", client_str)) {
            if (close(newsock_fd) < 0) {
               error("ERROR: Error closing client socket.");
            }

            // exit(0); /* If socket closure was successful, exit the program with 'normal' status code. */
            break; /* If socket closure was successful, exit the program with 'normal' status code. */
         }

         /* Clear the buffer of any data read from the client. */
         memset(client_str, 0, client_str_len);
      }

      /* Flush any data remaining in standard out. */
      fflush(stdout);
   }

   /* Close the server socket. */
   if (close(sock_fd) < 0) {
      error("ERROR: Error closing server socket.");
   }

   return 0;
}
